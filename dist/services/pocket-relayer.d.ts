import { CherryPicker } from '../services/cherry-picker';
import { MetricsRecorder } from '../services/metrics-recorder';
import { RelayResponse, HTTPMethod, Configuration as ConfigurationType } from '@pokt-network/pocket-js';
import { Redis } from 'ioredis';
import { BlockchainsRepository } from '../repositories';
import { Applications } from '../models';
import { pocketJSInstances } from '../application';
export declare class PocketRelayer {
    host: string;
    origin: string;
    userAgent: string;
    cherryPicker: CherryPicker;
    metricsRecorder: MetricsRecorder;
    redis: Redis;
    databaseEncryptionKey: string;
    secretKey: string;
    relayRetries: number;
    blockchainsRepository: BlockchainsRepository;
    checkDebug: boolean;
    fallbacks: Array<URL>;
    dispatchURL: string;
    pocketSessionBlockFrequency: number;
    pocketBlockTime: number;
    clientPrivateKey: string;
    clientPassphrase: string;
    pocketJSInstances: pocketJSInstances;
    constructor({ host, origin, userAgent, cherryPicker, metricsRecorder, redis, databaseEncryptionKey, secretKey, relayRetries, blockchainsRepository, checkDebug, fallbackURL, dispatchURL, pocketSessionBlockFrequency, pocketBlockTime, clientPrivateKey, clientPassphrase, pocketJSInstances }: {
        host: string;
        origin: string;
        userAgent: string;
        cherryPicker: CherryPicker;
        metricsRecorder: MetricsRecorder;
        redis: Redis;
        databaseEncryptionKey: string;
        secretKey: string;
        relayRetries: number;
        blockchainsRepository: BlockchainsRepository;
        checkDebug: boolean;
        fallbackURL: string;
        dispatchURL: string;
        pocketSessionBlockFrequency: number;
        pocketBlockTime: number;
        clientPrivateKey: string;
        clientPassphrase: string;
        pocketJSInstances: pocketJSInstances;
    });
    sendRelay(rawData: object, relayPath: string, httpMethod: HTTPMethod, application: Applications, requestID: string, requestTimeOut?: number, overallTimeOut?: number, relayRetries?: number): Promise<string | Error>;
    _sendRelay(data: string, relayPath: string, httpMethod: HTTPMethod, requestID: string, application: Applications, requestTimeOut: number | undefined, blockchain: string, blockchainEnforceResult: string): Promise<RelayResponse | Error>;
    parseMethod(parsedRawData: any): string;
    updateConfiguration(pocketConfiguration: ConfigurationType, requestTimeOut: number): any;
    loadBlockchain(): Promise<string[]>;
    checkEnforcementJSON(test: string): boolean;
    checkSecretKey(application: Applications): boolean;
    checkWhitelist(tests: string[], check: string, type: string): boolean;
}
